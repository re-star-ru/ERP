//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_bgb "bytes";_ba "crypto/aes";_b "crypto/cipher";_fgc "crypto/md5";_fgd "crypto/rand";_bf "crypto/rc4";_dc "crypto/sha256";_d "crypto/sha512";_fc "encoding/binary";_fg "errors";_cc "fmt";_fa "github.com/unidoc/unipdf/v3/common";
_f "hash";_bg "io";_c "math";);func (_daf stdHandlerR6 )alg2b (R int ,_bffc ,_eeab ,_bef []byte )([]byte ,error ){if R ==5{return _fag (_bffc );};return _gdc (_bffc ,_eeab ,_bef );};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ggf stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bgfe :=make ([]byte ,32);if _ ,_cbd :=_bg .ReadFull (_fgd .Reader ,_bgfe );_cbd !=nil {return nil ,_cbd ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _ecbd :=_ggf .alg8 (d ,_bgfe ,upass );_ecbd !=nil {return nil ,_ecbd ;};if _dbg :=_ggf .alg9 (d ,_bgfe ,opass );_dbg !=nil {return nil ,_dbg ;};if d .R ==5{return _bgfe ,nil ;
};if _caa :=_ggf .alg10 (d ,_bgfe );_caa !=nil {return nil ,_caa ;};return _bgfe ,nil ;};func (_dcd stdHandlerR6 )alg9 (_eee *StdEncryptDict ,_deb []byte ,_fead []byte )error {if _gbgd :=_afa ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_deb );_gbgd !=nil {return _gbgd ;
};if _fdd :=_afa ("\u0061\u006c\u0067\u0039","\u0055",48,_eee .U );_fdd !=nil {return _fdd ;};var _gfac [16]byte ;if _ ,_cdc :=_bg .ReadFull (_fgd .Reader ,_gfac [:]);_cdc !=nil {return _cdc ;};_feag :=_gfac [0:8];_fbg :=_gfac [8:16];_dced :=_eee .U [:48];
_cce :=make ([]byte ,len (_fead )+len (_feag )+len (_dced ));_bbfc :=copy (_cce ,_fead );_bbfc +=copy (_cce [_bbfc :],_feag );_bbfc +=copy (_cce [_bbfc :],_dced );_gcb ,_aba :=_dcd .alg2b (_eee .R ,_cce ,_fead ,_dced );if _aba !=nil {return _aba ;};O :=make ([]byte ,len (_gcb )+len (_feag )+len (_fbg ));
_bbfc =copy (O ,_gcb [:32]);_bbfc +=copy (O [_bbfc :],_feag );_bbfc +=copy (O [_bbfc :],_fbg );_eee .O =O ;_bbfc =len (_fead );_bbfc +=copy (_cce [_bbfc :],_fbg );_gcb ,_aba =_dcd .alg2b (_eee .R ,_cce ,_fead ,_dced );if _aba !=nil {return _aba ;};_bddg ,_aba :=_dab (_gcb [:32]);
if _aba !=nil {return _aba ;};_ddf :=make ([]byte ,_ba .BlockSize );_eda :=_b .NewCBCEncrypter (_bddg ,_ddf );OE :=make ([]byte ,32);_eda .CryptBlocks (OE ,_deb [:32]);_eee .OE =OE ;return nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_ccf stdHandlerR4 )alg3 (R int ,_fdg ,_ecb []byte )([]byte ,error ){var _gfe []byte ;if len (_ecb )> 0{_gfe =_ccf .alg3Key (R ,_ecb );}else {_gfe =_ccf .alg3Key (R ,_fdg );
};_afaa ,_deg :=_bf .NewCipher (_gfe );if _deg !=nil {return nil ,_fg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ag :=_ccf .paddedPass (_fdg );_fe :=make ([]byte ,len (_ag ));_afaa .XORKeyStream (_fe ,_ag );
if R >=3{_gaf :=make ([]byte ,len (_gfe ));for _edb :=0;_edb < 19;_edb ++{for _cd :=0;_cd < len (_gfe );_cd ++{_gaf [_cd ]=_gfe [_cd ]^byte (_edb +1);};_fea ,_bfb :=_bf .NewCipher (_gaf );if _bfb !=nil {return nil ,_fg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_fea .XORKeyStream (_fe ,_fe );};};return _fe ,nil ;};func _bfa (_ebf []byte ,_dcb int ){_dea :=_dcb ;for _dea < len (_ebf ){copy (_ebf [_dea :],_ebf [:_dea ]);_dea *=2;};};func _ca (_de _b .Block )_b .BlockMode {return (*ecbDecrypter )(_a (_de ))};type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};func (_caec stdHandlerR6 )alg12 (_gef *StdEncryptDict ,_feg []byte )([]byte ,error ){if _gage :=_afa ("\u0061\u006c\u00671\u0032","\u0055",48,_gef .U );_gage !=nil {return nil ,_gage ;};if _cceg :=_afa ("\u0061\u006c\u00671\u0032","\u004f",48,_gef .O );
_cceg !=nil {return nil ,_cceg ;};_ebe :=make ([]byte ,len (_feg )+8+48);_aea :=copy (_ebe ,_feg );_aea +=copy (_ebe [_aea :],_gef .O [32:40]);_aea +=copy (_ebe [_aea :],_gef .U [0:48]);_gad ,_cge :=_caec .alg2b (_gef .R ,_ebe ,_feg ,_gef .U [0:48]);if _cge !=nil {return nil ,_cge ;
};_gad =_gad [:32];if !_bgb .Equal (_gad ,_gef .O [:32]){return nil ,nil ;};return _gad ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type ecbDecrypter ecb ;var _ StdHandler =stdHandlerR4 {};func (_gadf stdHandlerR6 )alg13 (_bga *StdEncryptDict ,_cdbg []byte )error {if _adbc :=_afa ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_cdbg );
_adbc !=nil {return _adbc ;};if _bac :=_afa ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bga .Perms );_bac !=nil {return _bac ;};_ecba :=make ([]byte ,16);copy (_ecba ,_bga .Perms [:16]);_eead ,_aacc :=_ba .NewCipher (_cdbg [:32]);if _aacc !=nil {return _aacc ;
};_gagee :=_ca (_eead );_gagee .CryptBlocks (_ecba ,_ecba );if !_bgb .Equal (_ecba [9:12],[]byte ("\u0061\u0064\u0062")){return _fg .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_gca :=Permissions (_fc .LittleEndian .Uint32 (_ecba [0:4]));if _gca !=_bga .P {return _fg .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _fgdf bool ;if _ecba [8]=='T'{_fgdf =true ;}else if _ecba [8]=='F'{_fgdf =false ;}else {return _fg .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _fgdf !=_bga .EncryptMetadata {return _fg .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// Authenticate implements StdHandler interface.
func (_cde stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fa .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_fgb ,_bcb :=_cde .alg7 (d ,pass );if _bcb !=nil {return nil ,0,_bcb ;};if _fgb !=nil {_fa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fgb ,PermOwner ,nil ;
};_fa .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fgb ,_bcb =_cde .alg6 (d ,pass );if _bcb !=nil {return nil ,0,_bcb ;
};if _fgb !=nil {_fa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fgb ,d .P ,nil ;};return nil ,0,nil ;};func (_cae *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cae ._e !=0{_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cae ._cb .Decrypt (dst ,src [:_cae ._e ]);src =src [_cae ._e :];dst =dst [_cae ._e :];};};type ecbEncrypter ecb ;const (PermOwner =Permissions (_c .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);
PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););const _fb ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";


// Authenticate implements StdHandler interface.
func (_fge stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _fge .alg2a (d ,pass );};func (stdHandlerR4 )paddedPass (_fcg []byte )[]byte {_cbe :=make ([]byte ,32);_ec :=copy (_cbe ,_fcg );for ;_ec < 32;_ec ++{_cbe [_ec ]=_fb [_ec -len (_fcg )];
};return _cbe ;};func (_baa stdHandlerR6 )alg2a (_bbe *StdEncryptDict ,_cab []byte )([]byte ,Permissions ,error ){if _fbb :=_afa ("\u0061\u006c\u00672\u0061","\u004f",48,_bbe .O );_fbb !=nil {return nil ,0,_fbb ;};if _ceaa :=_afa ("\u0061\u006c\u00672\u0061","\u0055",48,_bbe .U );
_ceaa !=nil {return nil ,0,_ceaa ;};if len (_cab )> 127{_cab =_cab [:127];};_aaf ,_aad :=_baa .alg12 (_bbe ,_cab );if _aad !=nil {return nil ,0,_aad ;};var (_bbb []byte ;_ddac []byte ;_bfc []byte ;);var _ecg Permissions ;if len (_aaf )!=0{_ecg =PermOwner ;
_ab :=make ([]byte ,len (_cab )+8+48);_abc :=copy (_ab ,_cab );_abc +=copy (_ab [_abc :],_bbe .O [40:48]);copy (_ab [_abc :],_bbe .U [0:48]);_bbb =_ab ;_ddac =_bbe .OE ;_bfc =_bbe .U [0:48];}else {_aaf ,_aad =_baa .alg11 (_bbe ,_cab );if _aad ==nil &&len (_aaf )==0{_aaf ,_aad =_baa .alg11 (_bbe ,[]byte (""));
};if _aad !=nil {return nil ,0,_aad ;}else if len (_aaf )==0{return nil ,0,nil ;};_ecg =_bbe .P ;_cbf :=make ([]byte ,len (_cab )+8);_cg :=copy (_cbf ,_cab );copy (_cbf [_cg :],_bbe .U [40:48]);_bbb =_cbf ;_ddac =_bbe .UE ;_bfc =nil ;};if _faf :=_afa ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_ddac );
_faf !=nil {return nil ,0,_faf ;};_ddac =_ddac [:32];_edf ,_aad :=_baa .alg2b (_bbe .R ,_bbb ,_cab ,_bfc );if _aad !=nil {return nil ,0,_aad ;};_afg ,_aad :=_ba .NewCipher (_edf [:32]);if _aad !=nil {return nil ,0,_aad ;};_bbf :=make ([]byte ,_ba .BlockSize );
_bdd :=_b .NewCBCDecrypter (_afg ,_bbf );_eeff :=make ([]byte ,32);_bdd .CryptBlocks (_eeff ,_ddac );if _bbe .R ==5{return _eeff ,_ecg ,nil ;};_aad =_baa .alg13 (_bbe ,_eeff );if _aad !=nil {return nil ,0,_aad ;};return _eeff ,_ecg ,nil ;};func (_bb stdHandlerR4 )alg3Key (R int ,_gg []byte )[]byte {_eef :=_fgc .New ();
_bfd :=_bb .paddedPass (_gg );_eef .Write (_bfd );if R >=3{for _afb :=0;_afb < 50;_afb ++{_gdd :=_eef .Sum (nil );_eef =_fgc .New ();_eef .Write (_gdd );};};_gcf :=_eef .Sum (nil );if R ==2{_gcf =_gcf [0:5];}else {_gcf =_gcf [0:_bb .Length /8];};return _gcf ;
};

// Allowed checks if a set of permissions can be granted.
func (_gc Permissions )Allowed (p2 Permissions )bool {return _gc &p2 ==p2 };func (_ea stdHandlerR6 )alg10 (_fdgb *StdEncryptDict ,_dgg []byte )error {if _ffe :=_afa ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_dgg );_ffe !=nil {return _ffe ;};
_gcg :=uint64 (uint32 (_fdgb .P ))|(_c .MaxUint32 <<32);Perms :=make ([]byte ,16);_fc .LittleEndian .PutUint64 (Perms [:8],_gcg );if _fdgb .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_faee :=_bg .ReadFull (_fgd .Reader ,Perms [12:16]);
_faee !=nil {return _faee ;};_gae ,_bfdf :=_dab (_dgg [:32]);if _bfdf !=nil {return _bfdf ;};_ecge :=_gf (_gae );_ecge .CryptBlocks (Perms ,Perms );_fdgb .Perms =Perms [:16];return nil ;};func (_dbe stdHandlerR4 )alg7 (_cfc *StdEncryptDict ,_gab []byte )([]byte ,error ){_dda :=_dbe .alg3Key (_cfc .R ,_gab );
_da :=make ([]byte ,len (_cfc .O ));if _cfc .R ==2{_ccg ,_daa :=_bf .NewCipher (_dda );if _daa !=nil {return nil ,_fg .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ccg .XORKeyStream (_da ,_cfc .O );}else if _cfc .R >=3{_efab :=append ([]byte {},_cfc .O ...);
for _dce :=0;_dce < 20;_dce ++{_fed :=append ([]byte {},_dda ...);for _dfa :=0;_dfa < len (_dda );_dfa ++{_fed [_dfa ]^=byte (19-_dce );};_aga ,_feb :=_bf .NewCipher (_fed );if _feb !=nil {return nil ,_fg .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_aga .XORKeyStream (_da ,_efab );_efab =append ([]byte {},_da ...);};}else {return nil ,_fg .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_defg ,_be :=_dbe .alg6 (_cfc ,_da );if _be !=nil {return nil ,nil ;};return _defg ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bc stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ce :=_bc .alg3 (d .R ,upass ,opass );if _ce !=nil {_fa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ce );
return nil ,_ce ;};d .O =O ;_fa .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_dg :=_bc .alg2 (d ,upass );U ,_ce :=_bc .alg5 (_dg ,upass );if _ce !=nil {_fa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ce );
return nil ,_ce ;};d .U =U ;_fa .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _dg ,nil ;};func (_gb stdHandlerR4 )alg6 (_ad *StdEncryptDict ,_fcb []byte )([]byte ,error ){var (_df []byte ;_geb error ;);_bff :=_gb .alg2 (_ad ,_fcb );
if _ad .R ==2{_df ,_geb =_gb .alg4 (_bff ,_fcb );}else if _ad .R >=3{_df ,_geb =_gb .alg5 (_bff ,_fcb );}else {return nil ,_fg .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _geb !=nil {return nil ,_geb ;};_fa .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_df ),string (_ad .U ));
_fdf :=_df ;_cff :=_ad .U ;if _ad .R >=3{if len (_fdf )> 16{_fdf =_fdf [0:16];};if len (_cff )> 16{_cff =_cff [0:16];};};if !_bgb .Equal (_fdf ,_cff ){return nil ,nil ;};return _bff ,nil ;};func _gf (_cf _b .Block )_b .BlockMode {return (*ecbEncrypter )(_a (_cf ))};
func (_fga *ecbDecrypter )BlockSize ()int {return _fga ._e };

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_af *StdEncryptDict ,_bd ,_ac []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_db *StdEncryptDict ,_aa []byte )([]byte ,Permissions ,error );};func (_dec stdHandlerR6 )alg11 (_efac *StdEncryptDict ,_febf []byte )([]byte ,error ){if _abb :=_afa ("\u0061\u006c\u00671\u0031","\u0055",48,_efac .U );_abb !=nil {return nil ,_abb ;
};_afaf :=make ([]byte ,len (_febf )+8);_acaf :=copy (_afaf ,_febf );_acaf +=copy (_afaf [_acaf :],_efac .U [32:40]);_adb ,_fbd :=_dec .alg2b (_efac .R ,_afaf ,_febf ,nil );if _fbd !=nil {return nil ,_fbd ;};_adb =_adb [:32];if !_bgb .Equal (_adb ,_efac .U [:32]){return nil ,nil ;
};return _adb ,nil ;};type stdHandlerR6 struct{};func (_ddd stdHandlerR4 )alg4 (_def []byte ,_efeg []byte )([]byte ,error ){_cad ,_bfe :=_bf .NewCipher (_def );if _bfe !=nil {return nil ,_fg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_efa :=[]byte (_fb );_feae :=make ([]byte ,len (_efa ));_cad .XORKeyStream (_feae ,_efa );return _feae ,nil ;};func (_gfa stdHandlerR4 )alg2 (_ga *StdEncryptDict ,_ee []byte )[]byte {_fa .Log .Trace ("\u0061\u006c\u0067\u0032");_eff :=_gfa .paddedPass (_ee );
_ebg :=_fgc .New ();_ebg .Write (_eff );_ebg .Write (_ga .O );var _efe [4]byte ;_fc .LittleEndian .PutUint32 (_efe [:],uint32 (_ga .P ));_ebg .Write (_efe [:]);_fa .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_efe );_ebg .Write ([]byte (_gfa .ID0 ));
_fa .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ga .R ,_ga .EncryptMetadata );if (_ga .R >=4)&&!_ga .EncryptMetadata {_ebg .Write ([]byte {0xff,0xff,0xff,0xff});
};_fd :=_ebg .Sum (nil );if _ga .R >=3{_ebg =_fgc .New ();for _dd :=0;_dd < 50;_dd ++{_ebg .Reset ();_ebg .Write (_fd [0:_gfa .Length /8]);_fd =_ebg .Sum (nil );};};if _ga .R >=3{return _fd [0:_gfa .Length /8];};return _fd [0:5];};func (_ef errInvalidField )Error ()string {return _cc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ef .Func ,_ef .Field ,_ef .Exp ,_ef .Got );
};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_ed *ecbEncrypter )BlockSize ()int {return _ed ._e };func (_gd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gd ._e !=0{_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gd ._cb .Encrypt (dst ,src [:_gd ._e ]);src =src [_gd ._e :];dst =dst [_gd ._e :];};};func _gdc (_dfdc ,_dbf ,_gbe []byte )([]byte ,error ){var (_ff ,_bcf ,_beg _f .Hash ;);_ff =_dc .New ();_agd :=make ([]byte ,64);_aac :=_ff ;
_aac .Write (_dfdc );K :=_aac .Sum (_agd [:0]);_cfg :=make ([]byte ,64*(127+64+48));_bec :=func (_gfeg int )([]byte ,error ){_gcfd :=len (_dbf )+len (K )+len (_gbe );_fdb :=_cfg [:_gcfd ];_dgf :=copy (_fdb ,_dbf );_dgf +=copy (_fdb [_dgf :],K [:]);_dgf +=copy (_fdb [_dgf :],_gbe );
if _dgf !=_gcfd {_fa .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_fg .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");
};K1 :=_cfg [:_gcfd *64];_bfa (K1 ,_gcfd );_aca ,_bae :=_dab (K [0:16]);if _bae !=nil {return nil ,_bae ;};_bad :=_b .NewCBCEncrypter (_aca ,K [16:32]);_bad .CryptBlocks (K1 ,K1 );E :=K1 ;_gag :=0;for _dceb :=0;_dceb < 16;_dceb ++{_gag +=int (E [_dceb ]%3);
};var _gbg _f .Hash ;switch _gag %3{case 0:_gbg =_ff ;case 1:if _bcf ==nil {_bcf =_d .New384 ();};_gbg =_bcf ;case 2:if _beg ==nil {_beg =_d .New ();};_gbg =_beg ;};_gbg .Reset ();_gbg .Write (E );K =_gbg .Sum (_agd [:0]);return E ,nil ;};for _cac :=0;
;{E ,_gddg :=_bec (_cac );if _gddg !=nil {return nil ,_gddg ;};_bda :=E [len (E )-1];_cac ++;if _cac >=64&&_bda <=uint8 (_cac -32){break ;};};return K [:32],nil ;};func (_gcfg stdHandlerR6 )alg8 (_cgd *StdEncryptDict ,_bdb []byte ,_gea []byte )error {if _ccgf :=_afa ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bdb );
_ccgf !=nil {return _ccgf ;};var _fae [16]byte ;if _ ,_dbfc :=_bg .ReadFull (_fgd .Reader ,_fae [:]);_dbfc !=nil {return _dbfc ;};_dac :=_fae [0:8];_ddgb :=_fae [8:16];_gfc :=make ([]byte ,len (_gea )+len (_dac ));_fcf :=copy (_gfc ,_gea );copy (_gfc [_fcf :],_dac );
_efae ,_cfb :=_gcfg .alg2b (_cgd .R ,_gfc ,_gea ,nil );if _cfb !=nil {return _cfb ;};U :=make ([]byte ,len (_efae )+len (_dac )+len (_ddgb ));_fcf =copy (U ,_efae [:32]);_fcf +=copy (U [_fcf :],_dac );copy (U [_fcf :],_ddgb );_cgd .U =U ;_fcf =len (_gea );
copy (_gfc [_fcf :],_ddgb );_efae ,_cfb =_gcfg .alg2b (_cgd .R ,_gfc ,_gea ,nil );if _cfb !=nil {return _cfb ;};_ae ,_cfb :=_dab (_efae [:32]);if _cfb !=nil {return _cfb ;};_cdb :=make ([]byte ,_ba .BlockSize );_add :=_b .NewCBCEncrypter (_ae ,_cdb );UE :=make ([]byte ,32);
_add .CryptBlocks (UE ,_bdb [:32]);_cgd .UE =UE ;return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _fag (_bbc []byte )([]byte ,error ){_fcbe :=_dc .New ();_fcbe .Write (_bbc );return _fcbe .Sum (nil ),nil ;};type ecb struct{_cb _b .Block ;_e int ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);func _a (_bgc _b .Block )*ecb {return &ecb {_cb :_bgc ,_e :_bgc .BlockSize ()}};func (_gde stdHandlerR4 )alg5 (_fgg []byte ,_ccd []byte )([]byte ,error ){_fec :=_fgc .New ();_fec .Write ([]byte (_fb ));_fec .Write ([]byte (_gde .ID0 ));_fbe :=_fec .Sum (nil );
_fa .Log .Trace ("\u0061\u006c\u0067\u0035");_fa .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fgg );_fa .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_gde .ID0 );if len (_fbe )!=16{return nil ,_fg .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_cadf ,_dcf :=_bf .NewCipher (_fgg );if _dcf !=nil {return nil ,_fg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ddg :=make ([]byte ,16);_cadf .XORKeyStream (_ddg ,_fbe );_eg :=make ([]byte ,len (_fgg ));
for _egf :=0;_egf < 19;_egf ++{for _dbc :=0;_dbc < len (_fgg );_dbc ++{_eg [_dbc ]=_fgg [_dbc ]^byte (_egf +1);};_cadf ,_dcf =_bf .NewCipher (_eg );if _dcf !=nil {return nil ,_fg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cadf .XORKeyStream (_ddg ,_ddg );_fa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_egf ,_eg );_fa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_egf ,_ddg );
};_gcd :=make ([]byte ,32);for _dbca :=0;_dbca < 16;_dbca ++{_gcd [_dbca ]=_ddg [_dbca ];};_ ,_dcf =_fgd .Read (_gcd [16:32]);if _dcf !=nil {return nil ,_fg .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _gcd ,nil ;};func _dab (_cea []byte )(_b .Block ,error ){_dfd ,_bgf :=_ba .NewCipher (_cea );if _bgf !=nil {_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bgf );
return nil ,_bgf ;};return _dfd ,nil ;};func _afa (_acd ,_acf string ,_fcc int ,_ge []byte )error {if len (_ge )< _fcc {return errInvalidField {Func :_acd ,Field :_acf ,Exp :_fcc ,Got :len (_ge )};};return nil ;};var _ StdHandler =stdHandlerR6 {};
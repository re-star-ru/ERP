//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";func NewStringsMap (tuples []StringsTuple )*StringsMap {_eac :=map[string ]string {};for _ ,_gdd :=range tuples {_eac [_gdd .Key ]=_gdd .Value ;};return &StringsMap {_eg :_eac };};func MakeRuneByteMap (length int )*RuneByteMap {_dc :=make (map[rune ]byte ,length );
return &RuneByteMap {_bc :_dc };};type StringsMap struct{_eg map[string ]string ;_dcda _b .RWMutex ;};type StringRuneMap struct{_ce map[string ]rune ;_ggce _b .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ce :m }};
func (_bge *RuneStringMap )Length ()int {_bge ._ccc .RLock ();defer _bge ._ccc .RUnlock ();return len (_bge ._e );};func (_ba *ByteRuneMap )Range (f func (_fg byte ,_bg rune )(_ae bool )){_ba ._fb .RLock ();defer _ba ._fb .RUnlock ();for _db ,_gf :=range _ba ._d {if f (_db ,_gf ){break ;
};};};func (_cf *RuneSet )Write (r rune ){_cf ._aac .Lock ();defer _cf ._aac .Unlock ();_cf ._gg [r ]=struct{}{}};type ByteRuneMap struct{_d map[byte ]rune ;_fb _b .RWMutex ;};func (_ca *StringsMap )Read (g string )(string ,bool ){_ca ._dcda .RLock ();
defer _ca ._dcda .RUnlock ();_agb ,_bed :=_ca ._eg [g ];return _agb ,_bed ;};func (_bdd *RuneUint16Map )Range (f func (_ed rune ,_gge uint16 )(_fd bool )){_bdd ._age .RLock ();defer _bdd ._age .RUnlock ();for _fgb ,_dbc :=range _bdd ._feb {if f (_fgb ,_dbc ){break ;
};};};type RuneSet struct{_gg map[rune ]struct{};_aac _b .RWMutex ;};func (_fc *ByteRuneMap )Write (b byte ,r rune ){_fc ._fb .Lock ();defer _fc ._fb .Unlock ();_fc ._d [b ]=r };func (_cc *RuneByteMap )Range (f func (_dg rune ,_ag byte )(_ga bool )){_cc ._aab .RLock ();
defer _cc ._aab .RUnlock ();for _af ,_da :=range _cc ._bc {if f (_af ,_da ){break ;};};};func (_ac *RuneUint16Map )Write (r rune ,g uint16 ){_ac ._age .Lock ();defer _ac ._age .Unlock ();_ac ._feb [r ]=g ;};func (_cca *StringsMap )Copy ()*StringsMap {_cca ._dcda .RLock ();
defer _cca ._dcda .RUnlock ();_gddd :=map[string ]string {};for _egc ,_gac :=range _cca ._eg {_gddd [_egc ]=_gac ;};return &StringsMap {_eg :_gddd };};func (_aeg *RuneUint16Map )Length ()int {_aeg ._age .RLock ();defer _aeg ._age .RUnlock ();return len (_aeg ._feb );
};func (_ad *RuneStringMap )Write (r rune ,s string ){_ad ._ccc .Lock ();defer _ad ._ccc .Unlock ();_ad ._e [r ]=s ;};func (_fae *StringRuneMap )Read (g string )(rune ,bool ){_fae ._ggce .RLock ();defer _fae ._ggce .RUnlock ();_afe ,_ada :=_fae ._ce [g ];
return _afe ,_ada ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_e :m }};type RuneUint16Map struct{_feb map[rune ]uint16 ;_age _b .RWMutex ;};func (_fgf *StringsMap )Range (f func (_dbg ,_gbb string )(_acf bool )){_fgf ._dcda .RLock ();
defer _fgf ._dcda .RUnlock ();for _eef ,_aece :=range _fgf ._eg {if f (_eef ,_aece ){break ;};};};func (_abg *RuneUint16Map )Delete (r rune ){_abg ._age .Lock ();defer _abg ._age .Unlock ();delete (_abg ._feb ,r );};type StringsTuple struct{Key ,Value string ;
};func (_afd *RuneUint16Map )RangeDelete (f func (_eb rune ,_bde uint16 )(_gad bool ,_fbf bool )){_afd ._age .Lock ();defer _afd ._age .Unlock ();for _ccf ,_dec :=range _afd ._feb {_bf ,_ef :=f (_ccf ,_dec );if _bf {delete (_afd ._feb ,_ccf );};if _ef {break ;
};};};func (_aa *ByteRuneMap )Length ()int {_aa ._fb .RLock ();defer _aa ._fb .RUnlock ();return len (_aa ._d )};func (_bgf *StringsMap )Write (g1 ,g2 string ){_bgf ._dcda .Lock ();defer _bgf ._dcda .Unlock ();_bgf ._eg [g1 ]=g2 ;};func (_agd *RuneSet )Exists (r rune )bool {_agd ._aac .RLock ();
defer _agd ._aac .RUnlock ();_ ,_dd :=_agd ._gg [r ];return _dd ;};type RuneStringMap struct{_e map[rune ]string ;_ccc _b .RWMutex ;};func (_dbe *RuneStringMap )Range (f func (_fe rune ,_ff string )(_ee bool )){_dbe ._ccc .RLock ();defer _dbe ._ccc .RUnlock ();
for _cd ,_bd :=range _dbe ._e {if f (_cd ,_bd ){break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};func (_fcf *StringRuneMap )Write (g string ,r rune ){_fcf ._ggce .Lock ();
defer _fcf ._ggce .Unlock ();_fcf ._ce [g ]=r ;};func (_aee *RuneStringMap )Read (r rune )(string ,bool ){_aee ._ccc .RLock ();defer _aee ._ccc .RUnlock ();_fa ,_ggc :=_aee ._e [r ];return _fa ,_ggc ;};func (_gd *RuneSet )Range (f func (_bac rune )(_aec bool )){_gd ._aac .RLock ();
defer _gd ._aac .RUnlock ();for _ab :=range _gd ._gg {if f (_ab ){break ;};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gg :make (map[rune ]struct{},length )}};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_feb :make (map[rune ]uint16 ,length )};
};func (_a *ByteRuneMap )Read (b byte )(rune ,bool ){_a ._fb .RLock ();defer _a ._fb .RUnlock ();_g ,_de :=_a ._d [b ];return _g ,_de ;};type RuneByteMap struct{_bc map[rune ]byte ;_aab _b .RWMutex ;};func (_cfb *RuneSet )Length ()int {_cfb ._aac .RLock ();
defer _cfb ._aac .RUnlock ();return len (_cfb ._gg )};func (_gda *RuneUint16Map )Read (r rune )(uint16 ,bool ){_gda ._age .RLock ();defer _gda ._age .RUnlock ();_baa ,_cg :=_gda ._feb [r ];return _baa ,_cg ;};func (_bb *RuneByteMap )Write (r rune ,b byte ){_bb ._aab .Lock ();
defer _bb ._aab .Unlock ();_bb ._bc [r ]=b ;};func (_c *RuneByteMap )Read (r rune )(byte ,bool ){_c ._aab .RLock ();defer _c ._aab .RUnlock ();_bag ,_be :=_c ._bc [r ];return _bag ,_be ;};func (_ea *StringRuneMap )Range (f func (_bbb string ,_bbg rune )(_dga bool )){_ea ._ggce .RLock ();
defer _ea ._ggce .RUnlock ();for _dcd ,_eeb :=range _ea ._ce {if f (_dcd ,_eeb ){break ;};};};func (_gb *StringRuneMap )Length ()int {_gb ._ggce .RLock ();defer _gb ._ggce .RUnlock ();return len (_gb ._ce );};func (_aef *RuneByteMap )Length ()int {_aef ._aab .RLock ();
defer _aef ._aab .RUnlock ();return len (_aef ._bc );};
//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_fg "github.com/unidoc/unipdf/v3/common";_g "math";);func (_c Matrix )Identity ()bool {return _c [0]==1&&_c [1]==0&&_c [2]==0&&_c [3]==0&&_c [4]==1&&_c [5]==0&&_c [6]==0&&_c [7]==0&&_c [8]==1;};const _ee =1e9;func (_df Matrix )Round (precision float64 )Matrix {for _b :=range _df {_df [_b ]=_g .Round (_df [_b ]/precision )*precision ;
};return _df ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_eea Point )Distance (b Point )float64 {return _g .Hypot (_eea .X -b .X ,_eea .Y -b .Y )};func (_fgc Matrix )Angle ()float64 {_ge :=_g .Atan2 (-_fgc [1],_fgc [0]);if _ge < 0.0{_ge +=2*_g .Pi ;
};return _ge /_g .Pi *180.0;};func (_dcg Matrix )ScalingFactorY ()float64 {return _g .Hypot (_dcg [3],_dcg [4])};func (_cc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_abb :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cc .transformByMatrix (_abb );};const _aac =1.0e-6;
const _fb =1e-10;func (_gfa Point )Displace (delta Point )Point {return Point {_gfa .X +delta .X ,_gfa .Y +delta .Y }};func (_gbe *Matrix )Concat (b Matrix ){*_gbe =Matrix {b [0]*_gbe [0]+b [1]*_gbe [3],b [0]*_gbe [1]+b [1]*_gbe [4],0,b [3]*_gbe [0]+b [4]*_gbe [3],b [3]*_gbe [1]+b [4]*_gbe [4],0,b [6]*_gbe [0]+b [7]*_gbe [3]+_gbe [6],b [6]*_gbe [1]+b [7]*_gbe [4]+_gbe [7],1};
_gbe .clampRange ();};func (_ad Matrix )Translation ()(float64 ,float64 ){return _ad [6],_ad [7]};const _agb =1e-6;type Point struct{X float64 ;Y float64 ;};func (_dgc Matrix )Rotate (theta float64 )Matrix {return _dgc .Mult (RotationMatrix (theta ))};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_gf Matrix )Mult (b Matrix )Matrix {_gf .Concat (b );return _gf };func (_adc Matrix )Unrealistic ()bool {_aae ,_cda ,_ab ,_bbf :=_g .Abs (_adc [0]),_g .Abs (_adc [1]),_g .Abs (_adc [3]),_g .Abs (_adc [4]);
_gd :=_aae > _agb &&_bbf > _agb ;_gab :=_cda > _agb &&_ab > _agb ;return !(_gd ||_gab );};func (_efa Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_efa .X +t *b .X ,Y :(1-t )*_efa .Y +t *b .Y };};func (_dc Matrix )Translate (tx ,ty float64 )Matrix {return _dc .Mult (TranslationMatrix (tx ,ty ))};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_afe Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_afe .X ,_afe .Y );
};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ag Matrix )Inverse ()(Matrix ,bool ){_bg ,_ec :=_ag [0],_ag [1];_gbc ,_dge :=_ag [3],_ag [4];_bd ,_da :=_ag [6],_ag [7];_cdg :=_bg *_dge -_ec *_gbc ;if _g .Abs (_cdg )< _aac {return Matrix {},false ;
};_dgd ,_ebg :=_dge /_cdg ,-_ec /_cdg ;_aa ,_cdgb :=-_gbc /_cdg ,_bg /_cdg ;_cg :=-(_dgd *_bd +_aa *_da );_ba :=-(_ebg *_bd +_cdgb *_da );return NewMatrix (_dgd ,_ebg ,_aa ,_cdgb ,_cg ,_ba ),true ;};func RotationMatrix (angle float64 )Matrix {_e :=_g .Cos (angle );
_dg :=_g .Sin (angle );return NewMatrix (_e ,_dg ,-_dg ,_e ,0,0);};func (_eb Matrix )String ()string {_ef ,_ca ,_bc ,_bb ,_gb ,_fa :=_eb [0],_eb [1],_eb [3],_eb [4],_eb [6],_eb [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ef ,_ca ,_bc ,_bb ,_gb ,_fa );
};func (_ga Matrix )Singular ()bool {return _g .Abs (_ga [0]*_ga [4]-_ga [1]*_ga [3])< _fb };func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_fea Point )Rotate (theta float64 )Point {_ccd :=_g .Hypot (_fea .X ,_fea .Y );_ffd :=_g .Atan2 (_fea .Y ,_fea .X );
_gge ,_efb :=_g .Sincos (_ffd +theta /180.0*_g .Pi );return Point {_ccd *_efb ,_ccd *_gge };};func (_caa *Matrix )Clone ()Matrix {return NewMatrix (_caa [0],_caa [1],_caa [3],_caa [4],_caa [6],_caa [7]);};func (_a *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_a [0],_a [1]=a ,b ;
_a [3],_a [4]=c ,d ;_a [6],_a [7]=tx ,ty ;_a .clampRange ();};func (_faa *Matrix )clampRange (){for _ged ,_gg :=range _faa {if _gg > _ee {_fg .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gg ,_ee );_faa [_ged ]=_ee ;
}else if _gg < -_ee {_fg .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gg ,-_ee );_faa [_ged ]=-_ee ;};};};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_ea Matrix )ScalingFactorX ()float64 {return _g .Hypot (_ea [0],_ea [1])};
func (_ebe *Point )transformByMatrix (_fgca Matrix ){_ebe .X ,_ebe .Y =_fgca .Transform (_ebe .X ,_ebe .Y )};func (_eg *Point )Set (x ,y float64 ){_eg .X ,_eg .Y =x ,y };type Matrix [9]float64 ;func (_cd Matrix )Scale (xScale ,yScale float64 )Matrix {return _cd .Mult (ScaleMatrix (xScale ,yScale ))};
func (_af Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ce :=x *_af [0]+y *_af [3]+_af [6];_ac :=x *_af [1]+y *_af [4]+_af [7];return _ce ,_ac ;};func (_ff *Matrix )Shear (x ,y float64 ){_ff .Concat (ShearMatrix (x ,y ))};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_fe :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_fe .clampRange ();return _fe ;};
//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "bytes";_de "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_da *codingContext )mps (_dac uint32 )int {return int (_da ._fc [_dac ])};
func (_gga *Encoder )emit (){if _gga ._gf ==_dfb {_gga ._gc =append (_gga ._gc ,_gga ._fg );_gga ._fg =make ([]byte ,_dfb );_gga ._gf =0;};_gga ._fg [_gga ._gf ]=_gga ._ag ;_gga ._gf ++;};func (_cgc *Encoder )EncodeBitmap (bm *_g .Bitmap ,duplicateLineRemoval bool )error {_de .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_dedf ,_agb uint8 ;_dg ,_ee ,_ac uint16 ;_bg ,_fa ,_gb byte ;_cff ,_fad ,_bgg int ;_af ,_gff []byte ;);for _eeb :=0;_eeb < bm .Height ;_eeb ++{_bg ,_fa =0,0;if _eeb >=2{_bg =bm .Data [(_eeb -2)*bm .RowStride ];};if _eeb >=1{_fa =bm .Data [(_eeb -1)*bm .RowStride ];
if duplicateLineRemoval {_fad =_eeb *bm .RowStride ;_af =bm .Data [_fad :_fad +bm .RowStride ];_bgg =(_eeb -1)*bm .RowStride ;_gff =bm .Data [_bgg :_bgg +bm .RowStride ];if _f .Equal (_af ,_gff ){_agb =_dedf ^1;_dedf =1;}else {_agb =_dedf ;_dedf =0;};};
};if duplicateLineRemoval {if _bb :=_cgc .encodeBit (_cgc ._ad ,_aa ,_agb );_bb !=nil {return _bb ;};if _dedf !=0{continue ;};};_gb =bm .Data [_eeb *bm .RowStride ];_dg =uint16 (_bg >>5);_ee =uint16 (_fa >>4);_bg <<=3;_fa <<=4;_ac =0;for _cff =0;_cff < bm .Width ;
_cff ++{_db :=uint32 (_dg <<11|_ee <<4|_ac );_ggge :=(_gb &0x80)>>7;_eb :=_cgc .encodeBit (_cgc ._ad ,_db ,_ggge );if _eb !=nil {return _eb ;};_dg <<=1;_ee <<=1;_ac <<=1;_dg |=uint16 ((_bg &0x80)>>7);_ee |=uint16 ((_fa &0x80)>>7);_ac |=uint16 (_ggge );
_acf :=_cff %8;_daf :=_cff /8+1;if _acf ==4&&_eeb >=2{_bg =0;if _daf < bm .RowStride {_bg =bm .Data [(_eeb -2)*bm .RowStride +_daf ];};}else {_bg <<=1;};if _acf ==3&&_eeb >=1{_fa =0;if _daf < bm .RowStride {_fa =bm .Data [(_eeb -1)*bm .RowStride +_daf ];
};}else {_fa <<=1;};if _acf ==7{_gb =0;if _daf < bm .RowStride {_gb =bm .Data [_eeb *bm .RowStride +_daf ];};}else {_gb <<=1;};_dg &=31;_ee &=127;_ac &=15;};};return nil ;};func (_cdb *Encoder )codeLPS (_bd *codingContext ,_edgc uint32 ,_gce uint16 ,_aff byte ){_cdb ._bf -=_gce ;
if _cdb ._bf < _gce {_cdb ._ge +=uint32 (_gce );}else {_cdb ._bf =_gce ;};if _bag [_aff ]._afd ==1{_bd .flipMps (_edgc );};_bd ._ab [_edgc ]=_bag [_aff ]._acbg ;_cdb .renormalize ();};func (_cbc *Encoder )byteOut (){if _cbc ._ag ==0xff{_cbc .rBlock ();
return ;};if _cbc ._ge < 0x8000000{_cbc .lBlock ();return ;};_cbc ._ag ++;if _cbc ._ag !=0xff{_cbc .lBlock ();return ;};_cbc ._ge &=0x7ffffff;_cbc .rBlock ();};var _ed =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
var _ _c .WriterTo =&Encoder {};func (_abd *Encoder )encodeIAID (_dceg ,_bcf int )error {if _abd ._dd ==nil {_abd ._dd =_cfd (1<<uint (_dceg ));};_bbgc :=uint32 (1<<uint32 (_dceg +1))-1;_bcf <<=uint (32-_dceg );_bdb :=uint32 (1);for _cfde :=0;_cfde < _dceg ;
_cfde ++{_gad :=_bdb &_bbgc ;_cef :=uint8 ((uint32 (_bcf )&0x80000000)>>31);if _fag :=_abd .encodeBit (_abd ._dd ,_gad ,_cef );_fag !=nil {return _fag ;};_bdb =(_bdb <<1)|uint32 (_cef );_bcf <<=1;};return nil ;};type Class int ;func (_ce Class )String ()string {switch _ce {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_faf *Encoder )encodeInteger (_add Class ,_cgcd int )error {const _ged ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _cgcd > 2000000000||_cgcd < -2000000000{return _fe .Errorf (_ged ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cgcd );
};_cae :=_faf ._ggg [_add ];_cda :=uint32 (1);var _fdc int ;for ;;_fdc ++{if _ed [_fdc ]._cd <=_cgcd &&_ed [_fdc ]._ded >=_cgcd {break ;};};if _cgcd < 0{_cgcd =-_cgcd ;};_cgcd -=int (_ed [_fdc ]._e );_ae :=_ed [_fdc ]._a ;for _bfb :=uint8 (0);_bfb < _ed [_fdc ]._gg ;
_bfb ++{_ffe :=_ae &1;if _fga :=_faf .encodeBit (_cae ,_cda ,_ffe );_fga !=nil {return _fe .Wrap (_fga ,_ged ,"");};_ae >>=1;if _cda &0x100> 0{_cda =(((_cda <<1)|uint32 (_ffe ))&0x1ff)|0x100;}else {_cda =(_cda <<1)|uint32 (_ffe );};};_cgcd <<=32-_ed [_fdc ]._b ;
for _cfg :=uint8 (0);_cfg < _ed [_fdc ]._b ;_cfg ++{_cad :=uint8 ((uint32 (_cgcd )&0x80000000)>>31);if _gaa :=_faf .encodeBit (_cae ,_cda ,_cad );_gaa !=nil {return _fe .Wrap (_gaa ,_ged ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cgcd <<=1;if _cda &0x100!=0{_cda =(((_cda <<1)|uint32 (_cad ))&0x1ff)|0x100;}else {_cda =(_cda <<1)|uint32 (_cad );};};return nil ;};func (_cfgd *Encoder )renormalize (){for {_cfgd ._bf <<=1;_cfgd ._ge <<=1;_cfgd ._ec --;if _cfgd ._ec ==0{_cfgd .byteOut ();
};if (_cfgd ._bf &0x8000)!=0{break ;};};};func (_df *Encoder )Init (){_df ._ad =_cfd (_gcc );_df ._bf =0x8000;_df ._ge =0;_df ._ec =12;_df ._fb =-1;_df ._ag =0;_df ._gf =0;_df ._fg =make ([]byte ,_dfb );for _bc :=0;_bc < len (_df ._ggg );_bc ++{_df ._ggg [_bc ]=_cfd (512);
};_df ._dd =nil ;};type state struct{_ggd uint16 ;_edf ,_acbg uint8 ;_afd uint8 ;};func (_geb *Encoder )code1 (_dce *codingContext ,_eg uint32 ,_dff uint16 ,_fee byte ){if _dce .mps (_eg )==1{_geb .codeMPS (_dce ,_eg ,_dff ,_fee );}else {_geb .codeLPS (_dce ,_eg ,_dff ,_fee );
};};func (_bff *Encoder )rBlock (){if _bff ._fb >=0{_bff .emit ();};_bff ._fb ++;_bff ._ag =uint8 (_bff ._ge >>20);_bff ._ge &=0xfffff;_bff ._ec =7;};func (_ceb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_eaf error ){_de .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _eaf =_ceb .encodeIAID (symbolCodeLength ,value );_eaf !=nil {return _fe .Wrap (_eaf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_dad *Encoder )Final (){_dad .flush ()};func (_ffb *Encoder )EncodeInteger (proc Class ,value int )(_ggf error ){_de .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ggf =_ffb .encodeInteger (proc ,value );_ggf !=nil {return _fe .Wrap (_ggf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func _cfd (_ea int )*codingContext {return &codingContext {_ab :make ([]byte ,_ea ),_fc :make ([]byte ,_ea )};
};func New ()*Encoder {_cg :=&Encoder {};_cg .Init ();return _cg };func (_bbf *Encoder )encodeOOB (_ggac Class )error {_acb :=_bbf ._ggg [_ggac ];_aef :=_bbf .encodeBit (_acb ,1,1);if _aef !=nil {return _aef ;};_aef =_bbf .encodeBit (_acb ,3,0);if _aef !=nil {return _aef ;
};_aef =_bbf .encodeBit (_acb ,6,0);if _aef !=nil {return _aef ;};_aef =_bbf .encodeBit (_acb ,12,0);if _aef !=nil {return _aef ;};return nil ;};type codingContext struct{_ab []byte ;_fc []byte ;};func (_caf *Encoder )setBits (){_dacc :=_caf ._ge +uint32 (_caf ._bf );
_caf ._ge |=0xffff;if _caf ._ge >=_dacc {_caf ._ge -=0x8000;};};func (_ca *Encoder )Flush (){_ca ._gf =0;_ca ._gc =nil ;_ca ._fb =-1};const (_gcc =65536;_dfb =20*1024;);func (_bae *Encoder )flush (){_bae .setBits ();_bae ._ge <<=_bae ._ec ;_bae .byteOut ();
_bae ._ge <<=_bae ._ec ;_bae .byteOut ();_bae .emit ();if _bae ._ag !=0xff{_bae ._fb ++;_bae ._ag =0xff;_bae .emit ();};_bae ._fb ++;_bae ._ag =0xac;_bae ._fb ++;_bae .emit ();};func (_adb *Encoder )dataSize ()int {return _dfb *len (_adb ._gc )+_adb ._gf };
func (_cgcf *Encoder )encodeBit (_dede *codingContext ,_cabg uint32 ,_afe uint8 )error {const _gcb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_cgcf ._eag ++;if _cabg >=uint32 (len (_dede ._ab )){return _fe .Errorf (_gcb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_cabg );
};_ffd :=_dede ._ab [_cabg ];_ga :=_dede .mps (_cabg );_dae :=_bag [_ffd ]._ggd ;_de .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_cgcf ._eag ,_afe ,_ffd ,_ga ,_dae ,_cgcf ._bf ,_cgcf ._ge ,_cgcf ._ec ,_cgcf ._ag ,_cgcf ._fb );
if _afe ==0{_cgcf .code0 (_dede ,_cabg ,_dae ,_ffd );}else {_cgcf .code1 (_dede ,_cabg ,_dae ,_ffd );};return nil ;};func (_dgf *Encoder )EncodeOOB (proc Class )(_deg error ){_de .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _deg =_dgf .encodeOOB (proc );_deg !=nil {return _fe .Wrap (_deg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_adc *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _cdg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _dbb int64 ;for _agc ,_ace :=range _adc ._gc {_cab ,_ada :=w .Write (_ace );if _ada !=nil {return 0,_fe .Wrapf (_ada ,_cdg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_agc );
};_dbb +=int64 (_cab );};_adc ._fg =_adc ._fg [:_adc ._gf ];_ddeb ,_dgd :=w .Write (_adc ._fg );if _dgd !=nil {return 0,_fe .Wrap (_dgd ,_cdg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_dbb +=int64 (_ddeb );return _dbb ,nil ;
};const _aa =0x9b25;func (_cga *Encoder )code0 (_gee *codingContext ,_bba uint32 ,_ebd uint16 ,_edgg byte ){if _gee .mps (_bba )==0{_cga .codeMPS (_gee ,_bba ,_ebd ,_edgg );}else {_cga .codeLPS (_gee ,_bba ,_ebd ,_edgg );};};type Encoder struct{_ge uint32 ;
_bf uint16 ;_ec ,_ag uint8 ;_fb int ;_eag int ;_gc [][]byte ;_fg []byte ;_gf int ;_ad *codingContext ;_ggg [13]*codingContext ;_dd *codingContext ;};func (_ddb *Encoder )Refine (iTemp ,iTarget *_g .Bitmap ,ox ,oy int )error {for _gef :=0;_gef < iTarget .Height ;
_gef ++{var _fcf int ;_geg :=_gef +oy ;var (_dge ,_cb ,_ede ,_dde ,_dc uint16 ;_abg ,_edg ,_fade ,_afb ,_eea byte ;);if _geg >=1&&(_geg -1)< iTemp .Height {_abg =iTemp .Data [(_geg -1)*iTemp .RowStride ];};if _geg >=0&&_geg < iTemp .Height {_edg =iTemp .Data [_geg *iTemp .RowStride ];
};if _geg >=-1&&_geg +1< iTemp .Height {_fade =iTemp .Data [(_geg +1)*iTemp .RowStride ];};if _gef >=1{_afb =iTarget .Data [(_gef -1)*iTarget .RowStride ];};_eea =iTarget .Data [_gef *iTarget .RowStride ];_fd :=uint (6+ox );_dge =uint16 (_abg >>_fd );_cb =uint16 (_edg >>_fd );
_ede =uint16 (_fade >>_fd );_dde =uint16 (_afb >>6);_ba :=uint (2-ox );_abg <<=_ba ;_edg <<=_ba ;_fade <<=_ba ;_afb <<=2;for _fcf =0;_fcf < iTarget .Width ;_fcf ++{_aga :=(_dge <<10)|(_cb <<7)|(_ede <<4)|(_dde <<1)|_dc ;_abb :=_eea >>7;_cc :=_ddb .encodeBit (_ddb ._ad ,uint32 (_aga ),_abb );
if _cc !=nil {return _cc ;};_dge <<=1;_cb <<=1;_ede <<=1;_dde <<=1;_dge |=uint16 (_abg >>7);_cb |=uint16 (_edg >>7);_ede |=uint16 (_fade >>7);_dde |=uint16 (_afb >>7);_dc =uint16 (_abb );_bbg :=_fcf %8;_ccc :=_fcf /8+1;if _bbg ==5+ox {_abg ,_edg ,_fade =0,0,0;
if _ccc < iTemp .RowStride &&_geg >=1&&(_geg -1)< iTemp .Height {_abg =iTemp .Data [(_geg -1)*iTemp .RowStride +_ccc ];};if _ccc < iTemp .RowStride &&_geg >=0&&_geg < iTemp .Height {_edg =iTemp .Data [_geg *iTemp .RowStride +_ccc ];};if _ccc < iTemp .RowStride &&_geg >=-1&&(_geg +1)< iTemp .Height {_fade =iTemp .Data [(_geg +1)*iTemp .RowStride +_ccc ];
};}else {_abg <<=1;_edg <<=1;_fade <<=1;};if _bbg ==5&&_gef >=1{_afb =0;if _ccc < iTarget .RowStride {_afb =iTarget .Data [(_gef -1)*iTarget .RowStride +_ccc ];};}else {_afb <<=1;};if _bbg ==7{_eea =0;if _ccc < iTarget .RowStride {_eea =iTarget .Data [_gef *iTarget .RowStride +_ccc ];
};}else {_eea <<=1;};_dge &=7;_cb &=7;_ede &=7;_dde &=7;};};return nil ;};func (_ccd *Encoder )Reset (){_ccd ._bf =0x8000;_ccd ._ge =0;_ccd ._ec =12;_ccd ._fb =-1;_ccd ._ag =0;_ccd ._dd =nil ;_ccd ._ad =_cfd (_gcc );};var _bag =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
type intEncRangeS struct{_cd ,_ded int ;_a ,_gg uint8 ;_e uint16 ;_b uint8 ;};func (_cbd *Encoder )lBlock (){if _cbd ._fb >=0{_cbd .emit ();};_cbd ._fb ++;_cbd ._ag =uint8 (_cbd ._ge >>19);_cbd ._ge &=0x7ffff;_cbd ._ec =8;};func (_fbd *Encoder )codeMPS (_ef *codingContext ,_efa uint32 ,_dffe uint16 ,_egc byte ){_fbd ._bf -=_dffe ;
if _fbd ._bf &0x8000!=0{_fbd ._ge +=uint32 (_dffe );return ;};if _fbd ._bf < _dffe {_fbd ._bf =_dffe ;}else {_fbd ._ge +=uint32 (_dffe );};_ef ._ab [_efa ]=_bag [_egc ]._edf ;_fbd .renormalize ();};func (_ff *codingContext )flipMps (_cf uint32 ){_ff ._fc [_cf ]=1-_ff ._fc [_cf ]};
func (_eaa *Encoder )DataSize ()int {return _eaa .dataSize ()};
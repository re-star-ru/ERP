//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_ae "errors";_a "fmt";_gc "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/internal/bitwise";_ad "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "io";);type Decoder struct{_aeb ,_ga int ;_be *runData ;_bd []*code ;
_ebf []*code ;_ba []*code ;};func (_bcg *Decoder )fillBitmap (_ffd *_ad .Bitmap ,_dd int ,_gee []int ,_geb int )error {var _gba byte ;_fdg :=0;_baa :=_ffd .GetByteIndex (_fdg ,_dd );for _abb :=0;_abb < _geb ;_abb ++{_fbg :=byte (1);_bab :=_gee [_abb ];
if (_abb &1)==0{_fbg =0;};for _fdg < _bab {_gba =(_gba <<1)|_fbg ;_fdg ++;if (_fdg &7)==0{if _fa :=_ffd .SetByte (_baa ,_gba );_fa !=nil {return _fa ;};_baa ++;_gba =0;};};};if (_fdg &7)!=0{_gba <<=uint (8-(_fdg &7));if _daed :=_ffd .SetByte (_baa ,_gba );
_daed !=nil {return _daed ;};};return nil ;};const (_fbc mmrCode =iota ;_gcf ;_de ;_cd ;_ee ;_deb ;_gce ;_afc ;_fe ;_ca ;_aeg ;);const (EOF =-3;_gec =-2;EOL =-1;_fd =8;_eb =(1<<_fd )-1;_cb =5;_gbe =(1<<_cb )-1;);func New (r _ag .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_bge :=&Decoder {_aeb :width ,_ga :height };
_cc ,_ab :=_ag .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _ab !=nil {return nil ,_ab ;};_da ,_ab :=_baad (_cc );if _ab !=nil {return nil ,_ab ;};_bge ._be =_da ;if _ebd :=_bge .initTables ();_ebd !=nil {return nil ,_ebd ;};return _bge ,nil ;
};const (_def int =1024<<7;_gga int =3;_ega uint =24;);func (_efga *Decoder )uncompress2d (_gca *runData ,_ged []int ,_cg int ,_ebb []int ,_gcc int )(int ,error ){var (_ggf int ;_ecc int ;_fdf int ;_aaa =true ;_fgf error ;_acf *code ;);_ged [_cg ]=_gcc ;
_ged [_cg +1]=_gcc ;_ged [_cg +2]=_gcc +1;_ged [_cg +3]=_gcc +1;_aaf :for _fdf < _gcc {_acf ,_fgf =_gca .uncompressGetCode (_efga ._ba );if _fgf !=nil {return EOL ,nil ;};if _acf ==nil {_gca ._egfg ++;break _aaf ;};_gca ._egfg +=_acf ._ge ;switch mmrCode (_acf ._f ){case _de :_fdf =_ged [_ggf ];
case _cd :_fdf =_ged [_ggf ]+1;case _gce :_fdf =_ged [_ggf ]-1;case _gcf :for {var _dba []*code ;if _aaa {_dba =_efga ._bd ;}else {_dba =_efga ._ebf ;};_acf ,_fgf =_gca .uncompressGetCode (_dba );if _fgf !=nil {return 0,_fgf ;};if _acf ==nil {break _aaf ;
};_gca ._egfg +=_acf ._ge ;if _acf ._f < 64{if _acf ._f < 0{_ebb [_ecc ]=_fdf ;_ecc ++;_acf =nil ;break _aaf ;};_fdf +=_acf ._f ;_ebb [_ecc ]=_fdf ;_ecc ++;break ;};_fdf +=_acf ._f ;};_bed :=_fdf ;_dce :for {var _cba []*code ;if !_aaa {_cba =_efga ._bd ;
}else {_cba =_efga ._ebf ;};_acf ,_fgf =_gca .uncompressGetCode (_cba );if _fgf !=nil {return 0,_fgf ;};if _acf ==nil {break _aaf ;};_gca ._egfg +=_acf ._ge ;if _acf ._f < 64{if _acf ._f < 0{_ebb [_ecc ]=_fdf ;_ecc ++;break _aaf ;};_fdf +=_acf ._f ;if _fdf < _gcc ||_fdf !=_bed {_ebb [_ecc ]=_fdf ;
_ecc ++;};break _dce ;};_fdf +=_acf ._f ;};for _fdf < _gcc &&_ged [_ggf ]<=_fdf {_ggf +=2;};continue _aaf ;case _fbc :_ggf ++;_fdf =_ged [_ggf ];_ggf ++;continue _aaf ;case _ee :_fdf =_ged [_ggf ]+2;case _afc :_fdf =_ged [_ggf ]-2;case _deb :_fdf =_ged [_ggf ]+3;
case _fe :_fdf =_ged [_ggf ]-3;default:if _gca ._egfg ==12&&_acf ._f ==EOL {_gca ._egfg =0;if _ ,_fgf =_efga .uncompress1d (_gca ,_ged ,_gcc );_fgf !=nil {return 0,_fgf ;};_gca ._egfg ++;if _ ,_fgf =_efga .uncompress1d (_gca ,_ebb ,_gcc );_fgf !=nil {return 0,_fgf ;
};_dfa ,_gad :=_efga .uncompress1d (_gca ,_ged ,_gcc );if _gad !=nil {return EOF ,_gad ;};_gca ._egfg ++;return _dfa ,nil ;};_fdf =_gcc ;continue _aaf ;};if _fdf <=_gcc {_aaa =!_aaa ;_ebb [_ecc ]=_fdf ;_ecc ++;if _ggf > 0{_ggf --;}else {_ggf ++;};for _fdf < _gcc &&_ged [_ggf ]<=_fdf {_ggf +=2;
};};};if _ebb [_ecc ]!=_gcc {_ebb [_ecc ]=_gcc ;};if _acf ==nil {return EOL ,nil ;};return _ecc ,nil ;};func (_dfcc *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_gggg :=_dfcc ._egfg -_dfcc ._eaa ;if _gggg < 0||_gggg > 24{_eaaa :=(_dfcc ._egfg >>3)-_dfcc ._bfb ;
if _eaaa >=_dfcc ._eeff {_eaaa +=_dfcc ._bfb ;if _cfb :=_dfcc .fillBuffer (_eaaa );_cfb !=nil {return 0,_cfb ;};_eaaa -=_dfcc ._bfb ;};_gff :=(uint32 (_dfcc ._fcc [_eaaa ]&0xFF)<<16)|(uint32 (_dfcc ._fcc [_eaaa +1]&0xFF)<<8)|(uint32 (_dfcc ._fcc [_eaaa +2]&0xFF));
_fac :=uint32 (_dfcc ._egfg &7);_gff <<=_fac ;_dfcc ._fc =int (_gff );}else {_gd :=_dfcc ._eaa &7;_fce :=7-_gd ;if _gggg <=_fce {_dfcc ._fc <<=uint (_gggg );}else {_efa :=(_dfcc ._eaa >>3)+3-_dfcc ._bfb ;if _efa >=_dfcc ._eeff {_efa +=_dfcc ._bfb ;if _eeb :=_dfcc .fillBuffer (_efa );
_eeb !=nil {return 0,_eeb ;};_efa -=_dfcc ._bfb ;};_gd =8-_gd ;for {_dfcc ._fc <<=uint (_gd );_dfcc ._fc |=int (uint (_dfcc ._fcc [_efa ])&0xFF);_gggg -=_gd ;_efa ++;_gd =8;if !(_gggg >=8){break ;};};_dfcc ._fc <<=uint (_gggg );};};_dfcc ._eaa =_dfcc ._egfg ;
return _dfcc ._fc ,nil ;};func (_cag *Decoder )UncompressMMR ()(_dae *_ad .Bitmap ,_caa error ){_dae =_ad .New (_cag ._aeb ,_cag ._ga );_fea :=make ([]int ,_dae .Width +5);_fg :=make ([]int ,_dae .Width +5);_fg [0]=_dae .Width ;_gf :=1;var _ac int ;for _eef :=0;
_eef < _dae .Height ;_eef ++{_ac ,_caa =_cag .uncompress2d (_cag ._be ,_fg ,_gf ,_fea ,_dae .Width );if _caa !=nil {return nil ,_caa ;};if _ac ==EOF {break ;};if _ac > 0{_caa =_cag .fillBitmap (_dae ,_eef ,_fea ,_ac );if _caa !=nil {return nil ,_caa ;};
};_fg ,_fea =_fea ,_fg ;_gf =_ac ;};if _caa =_cag .detectAndSkipEOL ();_caa !=nil {return nil ,_caa ;};_cag ._be .align ();return _dae ,nil ;};func (_baaa *Decoder )uncompress1d (_ageg *runData ,_adg []int ,_fed int )(int ,error ){var (_efg =true ;_db int ;
_agf *code ;_eeg int ;_eab error ;);_gg :for _db < _fed {_ccg :for {if _efg {_agf ,_eab =_ageg .uncompressGetCode (_baaa ._bd );if _eab !=nil {return 0,_eab ;};}else {_agf ,_eab =_ageg .uncompressGetCode (_baaa ._ebf );if _eab !=nil {return 0,_eab ;};};
_ageg ._egfg +=_agf ._ge ;if _agf ._f < 0{break _gg ;};_db +=_agf ._f ;if _agf ._f < 64{_efg =!_efg ;_adg [_eeg ]=_db ;_eeg ++;break _ccg ;};};};if _adg [_eeg ]!=_fed {_adg [_eeg ]=_fed ;};_egc :=EOL ;if _agf !=nil &&_agf ._f !=EOL {_egc =_eeg ;};return _egc ,nil ;
};func (_ec *Decoder )createLittleEndianTable (_eg [][3]int )([]*code ,error ){_fbe :=make ([]*code ,_eb +1);for _fba :=0;_fba < len (_eg );_fba ++{_dc :=_d (_eg [_fba ]);if _dc ._ge <=_fd {_egf :=_fd -_dc ._ge ;_ebe :=_dc ._b <<uint (_egf );for _ccc :=(1<<uint (_egf ))-1;
_ccc >=0;_ccc --{_bc :=_ebe |_ccc ;_fbe [_bc ]=_dc ;};}else {_bb :=_dc ._b >>uint (_dc ._ge -_fd );if _fbe [_bb ]==nil {var _cab =_d ([3]int {});_cab ._age =make ([]*code ,_gbe +1);_fbe [_bb ]=_cab ;};if _dc ._ge <=_fd +_cb {_aa :=_fd +_cb -_dc ._ge ;_ef :=(_dc ._b <<uint (_aa ))&_gbe ;
_fbe [_bb ]._c =true ;for _cf :=(1<<uint (_aa ))-1;_cf >=0;_cf --{_fbe [_bb ]._age [_ef |_cf ]=_dc ;};}else {return nil ,_ae .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _fbe ,nil ;};type code struct{_ge int ;_b int ;_f int ;_age []*code ;_c bool ;};func (_edde *runData )align (){_edde ._egfg =((_edde ._egfg +7)>>3)<<3};type runData struct{_edd *_ag .SubstreamReader ;_egfg int ;_eaa int ;_fc int ;_fcc []byte ;
_bfb int ;_eeff int ;};func (_ed *code )String ()string {return _a .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_ed ._ge ,_ed ._b ,_ed ._f );};func _baad (_bgeb *_ag .SubstreamReader )(*runData ,error ){_bdc :=&runData {_edd :_bgeb ,_egfg :0,_eaa :1};
_cbaa :=_ea (_af (_gga ,int (_bgeb .Length ())),_def );_bdc ._fcc =make ([]byte ,_cbaa );if _ebc :=_bdc .fillBuffer (0);_ebc !=nil {if _ebc ==_e .EOF {_bdc ._fcc =make ([]byte ,10);_gc .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_ebc );
}else {return nil ,_ebc ;};};return _bdc ,nil ;};func (_bfg *runData )fillBuffer (_gbg int )error {_bfg ._bfb =_gbg ;_ ,_eefa :=_bfg ._edd .Seek (int64 (_gbg ),_e .SeekStart );if _eefa !=nil {if _eefa ==_e .EOF {_gc .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_bfg ._eeff =-1;}else {return _eefa ;};};if _eefa ==nil {_bfg ._eeff ,_eefa =_bfg ._edd .Read (_bfg ._fcc );if _eefa !=nil {if _eefa ==_e .EOF {_gc .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_bfg ._eeff =-1;}else {return _eefa ;};
};};if _bfg ._eeff > -1&&_bfg ._eeff < 3{for _bfg ._eeff < 3{_dfcd ,_ege :=_bfg ._edd .ReadByte ();if _ege !=nil {if _ege ==_e .EOF {_bfg ._fcc [_bfg ._eeff ]=0;}else {return _ege ;};}else {_bfg ._fcc [_bfg ._eeff ]=_dfcd &0xFF;};_bfg ._eeff ++;};};_bfg ._eeff -=3;
if _bfg ._eeff < 0{_bfg ._fcc =make ([]byte ,len (_bfg ._fcc ));_bfg ._eeff =len (_bfg ._fcc )-3;};return nil ;};func (_cca *Decoder )detectAndSkipEOL ()error {for {_bdf ,_bce :=_cca ._be .uncompressGetCode (_cca ._ba );if _bce !=nil {return _bce ;};if _bdf !=nil &&_bdf ._f ==EOL {_cca ._be ._egfg +=_bdf ._ge ;
}else {return nil ;};};};type mmrCode int ;func _af (_bf ,_fb int )int {if _bf < _fb {return _fb ;};return _bf ;};var (_ff =[][3]int {{4,0x1,int (_fbc )},{3,0x1,int (_gcf )},{1,0x1,int (_de )},{3,0x3,int (_cd )},{6,0x3,int (_ee )},{7,0x3,int (_deb )},{3,0x2,int (_gce )},{6,0x2,int (_afc )},{7,0x2,int (_fe )},{10,0xf,int (_ca )},{12,0xf,int (_aeg )},{12,0x1,int (EOL )}};
_df =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_gec },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_gec },{11,0x01,_gec },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_fde =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_gec },{9,0x18,15},{10,0x01,_gec },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_gec },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_daef *Decoder )initTables ()(_fda error ){if _daef ._bd ==nil {_daef ._bd ,_fda =_daef .createLittleEndianTable (_df );if _fda !=nil {return ;};_daef ._ebf ,_fda =_daef .createLittleEndianTable (_fde );if _fda !=nil {return ;};_daef ._ba ,_fda =_daef .createLittleEndianTable (_ff );
if _fda !=nil {return ;};};return nil ;};func _d (_gb [3]int )*code {return &code {_ge :_gb [0],_b :_gb [1],_f :_gb [2]}};func _ea (_ce ,_bg int )int {if _ce > _bg {return _bg ;};return _ce ;};func (_efd *runData )uncompressGetCodeLittleEndian (_beb []*code )(*code ,error ){_afa ,_ggg :=_efd .uncompressGetNextCodeLittleEndian ();
if _ggg !=nil {_gc .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_ggg );
return nil ,_ggg ;};_afa &=0xffffff;_gfg :=_afa >>(_ega -_fd );_dg :=_beb [_gfg ];if _dg !=nil &&_dg ._c {_gfg =(_afa >>(_ega -_fd -_cb ))&_gbe ;_dg =_dg ._age [_gfg ];};return _dg ,nil ;};func (_dbc *runData )uncompressGetCode (_dfc []*code )(*code ,error ){return _dbc .uncompressGetCodeLittleEndian (_dfc );
};
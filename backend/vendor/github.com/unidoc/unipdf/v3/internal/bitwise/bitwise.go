//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_g "encoding/binary";_dd "errors";_gc "github.com/unidoc/unipdf/v3/common";_ga "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_cad *Writer )UseMSB ()bool {return _cad ._agf };func (_aaa *SubstreamReader )readUnalignedByte ()(_edg byte ,_ggc error ){_dec :=_aaa ._cf ;
_edg =_aaa ._dfb <<(8-_dec );_aaa ._dfb ,_ggc =_aaa .readBufferByte ();if _ggc !=nil {return 0,_ggc ;};_edg |=_aaa ._dfb >>_dec ;_aaa ._dfb &=1<<_dec -1;return _edg ,nil ;};func (_dgb *SubstreamReader )readBufferByte ()(byte ,error ){if _dgb ._gdf >=_dgb ._ega {return 0,_b .EOF ;
};if _dgb ._gdf >=_dgb ._cgf ||_dgb ._gdf < _dgb ._agd {if _gabd :=_dgb .fillBuffer ();_gabd !=nil {return 0,_gabd ;};};_ggca :=_dgb ._cde [_dgb ._gdf -_dgb ._agd ];_dgb ._gdf ++;return _ggca ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_df :true }};
func (_aacb *Writer )Data ()[]byte {return _aacb ._gdea };func (_cd *BufferedWriter )Write (d []byte )(int ,error ){_cd .expandIfNeeded (len (d ));if _cd ._e ==0{return _cd .writeFullBytes (d ),nil ;};return _cd .writeShiftedBytes (d ),nil ;};func (_dac *SubstreamReader )ReadBits (n byte )(_eeegd uint64 ,_ef error ){if n < _dac ._cf {_gcbc :=_dac ._cf -n ;
_eeegd =uint64 (_dac ._dfb >>_gcbc );_dac ._dfb &=1<<_gcbc -1;_dac ._cf =_gcbc ;return _eeegd ,nil ;};if n > _dac ._cf {if _dac ._cf > 0{_eeegd =uint64 (_dac ._dfb );n -=_dac ._cf ;};var _gace byte ;for n >=8{_gace ,_ef =_dac .readBufferByte ();if _ef !=nil {return 0,_ef ;
};_eeegd =_eeegd <<8+uint64 (_gace );n -=8;};if n > 0{if _dac ._dfb ,_ef =_dac .readBufferByte ();_ef !=nil {return 0,_ef ;};_eaec :=8-n ;_eeegd =_eeegd <<n +uint64 (_dac ._dfb >>_eaec );_dac ._dfb &=1<<_eaec -1;_dac ._cf =_eaec ;}else {_dac ._cf =0;};
return _eeegd ,nil ;};_dac ._cf =0;return uint64 (_dac ._dfb ),nil ;};func (_eaed *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_eaed ._gdf =uint64 (offset );case _b .SeekCurrent :_eaed ._gdf +=uint64 (offset );
case _b .SeekEnd :_eaed ._gdf =_eaed ._ega +uint64 (offset );default:return 0,_dd .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_eaed ._cf =0;return int64 (_eaed ._gdf ),nil ;};func NewWriter (data []byte )*Writer {return &Writer {_gdea :data }};func (_cg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_bf :=int (_cg ._e )+skip ;if _bf >=0&&_bf < 8{_cg ._e =uint8 (_bf );
return nil ;};_bf =int (_cg ._e )+_cg ._gd *8+skip ;if _bf < 0{return _ga .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fa :=_bf /8;_ge :=_bf %8;_cg ._e =uint8 (_ge );if _ac :=_fa -_cg ._gd ;_ac > 0&&len (_cg ._f )-1< _fa {if _cg ._e !=0{_ac ++;};_cg .expandIfNeeded (_ac );};_cg ._gd =_fa ;return nil ;};func (_c *BufferedWriter )FinishByte (){if _c ._e ==0{return ;};
_c ._e =0;_c ._gd ++;};type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_afb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();StreamPosition ()int64 ;};func (_fb *SubstreamReader )Length ()uint64 {return _fb ._ega };type BitWriter interface{WriteBit (_bcag int )error ;WriteBits (_gab uint64 ,_de int )(_fee int ,_ed error );FinishByte ();SkipBits (_gca int )error ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_dd .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_gc .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_bfe :r ,_bab :offset ,_ega :length ,_cde :make ([]byte ,length )},nil ;};const (_da =64;_dc =int (^uint (0)>>1););func (_gf *SubstreamReader )ReadByte ()(byte ,error ){if _gf ._cf ==0{return _gf .readBufferByte ();};return _gf .readUnalignedByte ();
};func (_ag *BufferedWriter )expandIfNeeded (_fe int ){if !_ag .tryGrowByReslice (_fe ){_ag .grow (_fe );};};func NewReader (data []byte )*Reader {return &Reader {_eda :data }};func (_cfe *SubstreamReader )Offset ()uint64 {return _cfe ._bab };func (_daf *Reader )readBufferByte ()(byte ,error ){if _daf ._bdb >=int64 (len (_daf ._eda )){return 0,_b .EOF ;
};_daf ._aed =-1;_ffg :=_daf ._eda [_daf ._bdb ];_daf ._bdb ++;_daf ._afa =int (_ffg );return _ffg ,nil ;};func (_bfda *Writer )FinishByte (){if _bfda ._babf ==0{return ;};_bfda ._babf =0;_bfda ._gdbb ++;};func (_bca *BufferedWriter )fullOffset ()int {_eb :=_bca ._gd ;
if _bca ._e !=0{_eb ++;};return _eb ;};func (_gdc *BufferedWriter )writeByte (_be byte ){switch {case _gdc ._e ==0:_gdc ._f [_gdc ._gd ]=_be ;_gdc ._gd ++;case _gdc ._df :_gdc ._f [_gdc ._gd ]|=_be >>_gdc ._e ;_gdc ._gd ++;_gdc ._f [_gdc ._gd ]=byte (uint16 (_be )<<(8-_gdc ._e )&0xff);
default:_gdc ._f [_gdc ._gd ]|=byte (uint16 (_be )<<_gdc ._e &0xff);_gdc ._gd ++;_gdc ._f [_gdc ._gd ]=_be >>(8-_gdc ._e );};};func (_aafa *SubstreamReader )Reset (){_aafa ._gdf =_aafa ._gbb ;_aafa ._cf =_aafa ._ebe };func (_abd *SubstreamReader )Read (b []byte )(_fdf int ,_daa error ){if _abd ._gdf >=_abd ._ega {_gc .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_abd ._gdf ,_abd ._ega );
return 0,_b .EOF ;};for ;_fdf < len (b );_fdf ++{if b [_fdf ],_daa =_abd .readUnalignedByte ();_daa !=nil {if _daa ==_b .EOF {return _fdf ,nil ;};return 0,_daa ;};};return _fdf ,nil ;};func (_gb *BufferedWriter )WriteByte (bt byte )error {if _gb ._gd > len (_gb ._f )-1||(_gb ._gd ==len (_gb ._f )-1&&_gb ._e !=0){_gb .expandIfNeeded (1);
};_gb .writeByte (bt );return nil ;};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;Data ()[]byte ;};func (_fae *Reader )ReadBool ()(bool ,error ){return _fae .readBool ()};func (_bfa *SubstreamReader )ReadUint32 ()(uint32 ,error ){_agc :=make ([]byte ,4);
_ ,_abf :=_bfa .Read (_agc );if _abf !=nil {return 0,_abf ;};return _g .BigEndian .Uint32 (_agc ),nil ;};type Reader struct{_eda []byte ;_ea byte ;_ege byte ;_bdb int64 ;_afa int ;_aed int ;_dcg int64 ;_abc byte ;_eab byte ;_dcf int ;};func (_cefg *Writer )byteCapacity ()int {_gbcd :=len (_cefg ._gdea )-_cefg ._gdbb ;
if _cefg ._babf !=0{_gbcd --;};return _gbcd ;};func (_ab *BufferedWriter )Data ()[]byte {return _ab ._f };type BufferedWriter struct{_f []byte ;_e uint8 ;_gd int ;_df bool ;};func (_eeg *Writer )ResetBit (){_eeg ._babf =0};func (_aae *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_aae ._aed =-1;
var _ebf int64 ;switch whence {case _b .SeekStart :_ebf =offset ;case _b .SeekCurrent :_ebf =_aae ._bdb +offset ;case _b .SeekEnd :_ebf =int64 (len (_aae ._eda ))+offset ;default:return 0,_dd .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _ebf < 0{return 0,_dd .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_aae ._bdb =_ebf ;
_aae ._ege =0;return _ebf ,nil ;};func (_aa *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _aa ._ege !=0{return _aa .ReadBits (_aa ._ege );};return 0,nil ;};func (_dgad *Reader )ReadByte ()(byte ,error ){if _dgad ._ege ==0{return _dgad .readBufferByte ();
};return _dgad .readUnalignedByte ();};func (_ffad *Writer )Write (p []byte )(int ,error ){if len (p )> _ffad .byteCapacity (){return 0,_b .EOF ;};for _ ,_gdfc :=range p {if _aged :=_ffad .writeByte (_gdfc );_aged !=nil {return 0,_aged ;};};return len (p ),nil ;
};func (_fgd *Reader )Reset (){_fgd ._bdb =_fgd ._dcg ;_fgd ._ege =_fgd ._abc ;_fgd ._ea =_fgd ._eab ;_fgd ._afa =_fgd ._dcf ;};func (_cdc *Reader )Read (p []byte )(_ffac int ,_ccc error ){if _cdc ._ege ==0{return _cdc .read (p );};for ;_ffac < len (p );
_ffac ++{if p [_ffac ],_ccc =_cdc .readUnalignedByte ();_ccc !=nil {return 0,_ccc ;};};return _ffac ,nil ;};func (_cbg *SubstreamReader )Mark (){_cbg ._gbb =_cbg ._gdf ;_cbg ._ebe =_cbg ._cf };func (_dea *Reader )StreamPosition ()int64 {return _dea ._bdb };
type SubstreamReader struct{_gdf uint64 ;_bfe StreamReader ;_bab uint64 ;_ega uint64 ;_cde []byte ;_agd uint64 ;_cgf uint64 ;_dfb byte ;_cf byte ;_gbb uint64 ;_ebe byte ;};func (_aac *Reader )read (_fec []byte )(int ,error ){if _aac ._bdb >=int64 (len (_aac ._eda )){return 0,_b .EOF ;
};_aac ._aed =-1;_bfd :=copy (_fec ,_aac ._eda [_aac ._bdb :]);_aac ._bdb +=int64 (_bfd );return _bfd ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gdea :data ,_agf :true }};var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};
_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ba *BufferedWriter )Reset (){_ba ._f =_ba ._f [:0];_ba ._gd =0;_ba ._e =0};func (_cce *Writer )WriteBits (bits uint64 ,number int )(_bcc int ,_dgbg error ){const _afad ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ga .Errorf (_afad ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fffe :=number /8;if _fffe > 0{_acc :=number -_fffe *8;for _faee :=_fffe -1;_faee >=0;_faee --{_cbf :=byte ((bits >>uint (_faee *8+_acc ))&0xff);if _dgbg =_cce .WriteByte (_cbf );_dgbg !=nil {return _bcc ,_ga .Wrapf (_dgbg ,_afad ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fffe -_faee +1);
};};number -=_fffe *8;if number ==0{return _fffe ,nil ;};};var _edd int ;for _gbe :=0;_gbe < number ;_gbe ++{if _cce ._agf {_edd =int ((bits >>uint (number -1-_gbe ))&0x1);}else {_edd =int (bits &0x1);bits >>=1;};if _dgbg =_cce .WriteBit (_edd );_dgbg !=nil {return _bcc ,_ga .Wrapf (_dgbg ,_afad ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gbe );
};};return _fffe ,nil ;};func (_eabg *Writer )writeByte (_dgd byte )error {if _eabg ._gdbb > len (_eabg ._gdea )-1{return _b .EOF ;};if _eabg ._gdbb ==len (_eabg ._gdea )-1&&_eabg ._babf !=0{return _b .EOF ;};if _eabg ._babf ==0{_eabg ._gdea [_eabg ._gdbb ]=_dgd ;
_eabg ._gdbb ++;return nil ;};if _eabg ._agf {_eabg ._gdea [_eabg ._gdbb ]|=_dgd >>_eabg ._babf ;_eabg ._gdbb ++;_eabg ._gdea [_eabg ._gdbb ]=byte (uint16 (_dgd )<<(8-_eabg ._babf )&0xff);}else {_eabg ._gdea [_eabg ._gdbb ]|=byte (uint16 (_dgd )<<_eabg ._babf &0xff);
_eabg ._gdbb ++;_eabg ._gdea [_eabg ._gdbb ]=_dgd >>(8-_eabg ._babf );};return nil ;};var _ BinaryWriter =&Writer {};func (_gac *Reader )readBool ()(_caaa bool ,_ggb error ){if _gac ._ege ==0{_gac ._ea ,_ggb =_gac .readBufferByte ();if _ggb !=nil {return false ,_ggb ;
};_caaa =(_gac ._ea &0x80)!=0;_gac ._ea ,_gac ._ege =_gac ._ea &0x7f,7;return _caaa ,nil ;};_gac ._ege --;_caaa =(_gac ._ea &(1<<_gac ._ege ))!=0;_gac ._ea &=1<<_gac ._ege -1;return _caaa ,nil ;};func (_gegb *BufferedWriter )tryGrowByReslice (_ae int )bool {if _ffa :=len (_gegb ._f );
_ae <=cap (_gegb ._f )-_ffa {_gegb ._f =_gegb ._f [:_ffa +_ae ];return true ;};return false ;};func (_egc *Reader )Mark (){_egc ._dcg =_egc ._bdb ;_egc ._abc =_egc ._ege ;_egc ._eab =_egc ._ea ;_egc ._dcf =_egc ._afa ;};func (_fg *Reader )ReadBits (n byte )(_ca uint64 ,_dga error ){if n < _fg ._ege {_cef :=_fg ._ege -n ;
_ca =uint64 (_fg ._ea >>_cef );_fg ._ea &=1<<_cef -1;_fg ._ege =_cef ;return _ca ,nil ;};if n > _fg ._ege {if _fg ._ege > 0{_ca =uint64 (_fg ._ea );n -=_fg ._ege ;};for n >=8{_bdg ,_eae :=_fg .readBufferByte ();if _eae !=nil {return 0,_eae ;};_ca =_ca <<8+uint64 (_bdg );
n -=8;};if n > 0{if _fg ._ea ,_dga =_fg .readBufferByte ();_dga !=nil {return 0,_dga ;};_caa :=8-n ;_ca =_ca <<n +uint64 (_fg ._ea >>_caa );_fg ._ea &=1<<_caa -1;_fg ._ege =_caa ;}else {_fg ._ege =0;};return _ca ,nil ;};_fg ._ege =0;return uint64 (_fg ._ea ),nil ;
};func (_eef *Reader )Length ()uint64 {return uint64 (len (_eef ._eda ))};type Writer struct{_gdea []byte ;_babf uint8 ;_gdbb int ;_agf bool ;};func (_ddg *Reader )Align ()(_gde byte ){_gde =_ddg ._ege ;_ddg ._ege =0;return _gde };func _eeef (_abcg ,_fdc uint64 )uint64 {if _abcg < _fdc {return _abcg ;
};return _fdc ;};func (_gea *SubstreamReader )StreamPosition ()int64 {return int64 (_gea ._gdf )};func (_baa *Writer )writeBit (_dda uint8 )error {if len (_baa ._gdea )-1< _baa ._gdbb {return _b .EOF ;};_acg :=_baa ._babf ;if _baa ._agf {_acg =7-_baa ._babf ;
};_baa ._gdea [_baa ._gdbb ]|=byte (uint16 (_dda <<_acg )&0xff);_baa ._babf ++;if _baa ._babf ==8{_baa ._gdbb ++;_baa ._babf =0;};return nil ;};func (_bfdf *Writer )WriteByte (c byte )error {return _bfdf .writeByte (c )};func (_def *SubstreamReader )ReadBit ()(_gdg int ,_caef error ){_gda ,_caef :=_def .readBool ();
if _caef !=nil {return 0,_caef ;};if _gda {_gdg =1;};return _gdg ,nil ;};func (_ec *BufferedWriter )writeFullBytes (_bd []byte )int {_ff :=copy (_ec ._f [_ec .fullOffset ():],_bd );_ec ._gd +=_ff ;return _ff ;};func (_bec *Reader )readUnalignedByte ()(_cae byte ,_fff error ){_gdef :=_bec ._ege ;
_cae =_bec ._ea <<(8-_gdef );_bec ._ea ,_fff =_bec .readBufferByte ();if _fff !=nil {return 0,_fff ;};_cae |=_bec ._ea >>_gdef ;_bec ._ea &=1<<_gdef -1;return _cae ,nil ;};func (_aca *Writer )SkipBits (skip int )error {const _fcf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_gbca :=int (_aca ._babf )+skip ;if _gbca >=0&&_gbca < 8{_aca ._babf =uint8 (_gbca );return nil ;};_gbca =int (_aca ._babf )+_aca ._gdbb *8+skip ;if _gbca < 0{return _ga .Errorf (_fcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ddb :=_gbca /8;_ecd :=_gbca %8;_gc .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_gc .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_aca ._babf ,_aca ._gdbb ,int (_aca ._babf )+(_aca ._gdbb )*8,len (_aca ._gdea ),cap (_aca ._gdea ));
_gc .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_gbca ,_ecd );_aca ._babf =uint8 (_ecd );
if _aedb :=_ddb -_aca ._gdbb ;_aedb > 0&&len (_aca ._gdea )-1< _ddb {_gc .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_aedb );return _ga .Errorf (_fcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aca ._gdbb =_ddb ;_gc .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_aca ._babf ,_aca ._gdbb );return nil ;};
func (_dge *Reader )BitPosition ()int {return int (_dge ._ege )};var _ _b .ByteWriter =&BufferedWriter {};var _ BinaryWriter =&BufferedWriter {};var _ _b .Writer =&BufferedWriter {};func (_gdbg *SubstreamReader )readBool ()(_gfd bool ,_eeb error ){if _gdbg ._cf ==0{_gdbg ._dfb ,_eeb =_gdbg .readBufferByte ();
if _eeb !=nil {return false ,_eeb ;};_gfd =(_gdbg ._dfb &0x80)!=0;_gdbg ._dfb ,_gdbg ._cf =_gdbg ._dfb &0x7f,7;return _gfd ,nil ;};_gdbg ._cf --;_gfd =(_gdbg ._dfb &(1<<_gdbg ._cf ))!=0;_gdbg ._dfb &=1<<_gdbg ._cf -1;return _gfd ,nil ;};func (_fd *BufferedWriter )WriteBits (bits uint64 ,number int )(_eee int ,_gcb error ){const _ce ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ga .Errorf (_ce ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_gbd :=number /8;if _gbd > 0{_cc :=number -_gbd *8;for _ddd :=_gbd -1;_ddd >=0;_ddd --{_bc :=byte ((bits >>uint (_ddd *8+_cc ))&0xff);if _gcb =_fd .WriteByte (_bc );_gcb !=nil {return _eee ,_ga .Wrapf (_gcb ,_ce ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gbd -_ddd +1);
};};number -=_gbd *8;if number ==0{return _gbd ,nil ;};};var _eg int ;for _eeeg :=0;_eeeg < number ;_eeeg ++{if _fd ._df {_eg =int ((bits >>uint (number -1-_eeeg ))&0x1);}else {_eg =int (bits &0x1);bits >>=1;};if _gcb =_fd .WriteBit (_eg );_gcb !=nil {return _eee ,_ga .Wrapf (_gcb ,_ce ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_eeeg );
};};return _gbd ,nil ;};func (_gcc *BufferedWriter )writeShiftedBytes (_dfa []byte )int {for _ ,_afg :=range _dfa {_gcc .writeByte (_afg );};return len (_dfa );};func (_af *BufferedWriter )ResetBitIndex (){_af ._e =0};func (_ddf *SubstreamReader )BitPosition ()int {return int (_ddf ._cf )};
func (_cb *BufferedWriter )grow (_bcb int ){if _cb ._f ==nil &&_bcb < _da {_cb ._f =make ([]byte ,_bcb ,_da );return ;};_gag :=len (_cb ._f );if _cb ._e !=0{_gag ++;};_dcd :=cap (_cb ._f );switch {case _bcb <=_dcd /2-_gag :_gc .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_cb ._f ),cap (_cb ._f ),_bcb );
_gc .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_dcd ,_gag );copy (_cb ._f ,_cb ._f [_cb .fullOffset ():]);
case _dcd > _dc -_dcd -_bcb :_gc .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gcf :=make ([]byte ,2*_dcd +_bcb );copy (_gcf ,_cb ._f );_cb ._f =_gcf ;};_cb ._f =_cb ._f [:_gag +_bcb ];
};func (_fc *Reader )ReadBit ()(_aec int ,_dab error ){_bgf ,_dab :=_fc .readBool ();if _dab !=nil {return 0,_dab ;};if _bgf {_aec =1;};return _aec ,nil ;};func (_bbf *Reader )ReadUint32 ()(uint32 ,error ){_caab :=make ([]byte ,4);_ ,_aecg :=_bbf .Read (_caab );
if _aecg !=nil {return 0,_aecg ;};return _g .BigEndian .Uint32 (_caab ),nil ;};func (_ad *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ad .writeBit (uint8 (bit ));};return _ga .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_dabd *SubstreamReader )fillBuffer ()error {if uint64 (_dabd ._bfe .StreamPosition ())!=_dabd ._gdf +_dabd ._bab {_ ,_gege :=_dabd ._bfe .Seek (int64 (_dabd ._gdf +_dabd ._bab ),_b .SeekStart );if _gege !=nil {return _gege ;};};_dabd ._agd =_dabd ._gdf ;
_cge :=_eeef (uint64 (len (_dabd ._cde )),_dabd ._ega -_dabd ._gdf );_gage :=make ([]byte ,_cge );_cdb ,_ccf :=_dabd ._bfe .Read (_gage );if _ccf !=nil {return _ccf ;};for _ffd :=uint64 (0);_ffd < _cge ;_ffd ++{_dabd ._cde [_ffd ]=_gage [_ffd ];};_dabd ._cgf =_dabd ._agd +uint64 (_cdb );
return nil ;};func (_bg *BufferedWriter )byteCapacity ()int {_dfe :=len (_bg ._f )-_bg ._gd ;if _bg ._e !=0{_dfe --;};return _dfe ;};func (_bgc *SubstreamReader )Align ()(_cdcd byte ){_cdcd =_bgc ._cf ;_bgc ._cf =0;return _cdcd };func (_dg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ga .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_dg ._f )-1< _dg ._gd {_dg .expandIfNeeded (1);};_bb :=_dg ._e ;if _dg ._df {_bb =7-_dg ._e ;};_dg ._f [_dg ._gd ]|=byte (uint16 (bit <<_bb )&0xff);_dg ._e ++;if _dg ._e ==8{_dg ._gd ++;_dg ._e =0;};return nil ;};func (_ee *BufferedWriter )Len ()int {return _ee .byteCapacity ()};
func (_gdb *SubstreamReader )ReadBool ()(bool ,error ){return _gdb .readBool ()};